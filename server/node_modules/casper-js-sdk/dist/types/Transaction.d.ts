import { Hash } from './key';
import { Deploy } from './Deploy';
import { Duration, Timestamp } from './Time';
import { InitiatorAddr } from './InitiatorAddr';
import { PricingMode } from './PricingMode';
import { TransactionTarget } from './TransactionTarget';
import { TransactionEntryPoint } from './TransactionEntryPoint';
import { TransactionScheduling } from './TransactionScheduling';
import { PublicKey, PrivateKey } from './keypair';
import { HexBytes } from './HexBytes';
import { Args } from './Args';
import { TransactionV1Payload } from './TransactionV1Payload';
/**
 * Custom error class for handling transaction-related errors.
 */
export declare class TransactionError extends Error {
}
/**
 * Error to indicate an invalid transaction hash.
 */
export declare const ErrInvalidTransactionHash: TransactionError;
/**
 * Error to indicate an invalid approval signature in a transaction.
 */
export declare const ErrInvalidApprovalSignature: TransactionError;
/**
 * Error to indicate an issue parsing JSON as a TransactionV1.
 */
export declare const ErrTransactionV1FromJson: TransactionError;
/**
 * Enum representing the categories of transactions.
 */
export declare enum TransactionCategory {
    Mint = 0,
    Auction = 1,
    InstallUpgrade = 2,
    Large = 3,
    Medium = 4,
    Small = 5
}
/**
 * Enum representing the versions of transactions.
 */
export declare enum TransactionVersion {
    V1 = 0,
    Deploy = 1
}
/**
 * Represents a transaction hash, which can either be associated with a `Deploy` or a `TransactionV1`.
 */
export declare class TransactionHash extends Hash {
    /**
     * The hash associated with the deploy transaction, if applicable.
     * This will contain the hash of the `Deploy` transaction.
     */
    deploy?: Hash;
    /**
     * The hash associated with the version 1 transaction, if applicable.
     * This will contain the hash of the `TransactionV1`.
     */
    transactionV1?: Hash;
    /**
     * Constructs a new `TransactionHash` instance, which can hold either a `Deploy` hash or a `TransactionV1` hash.
     * @param deploy The hash of the deploy transaction, if applicable.
     * @param transactionV1 The hash of the version 1 transaction, if applicable.
     */
    private constructor();
    /**
     * Creates a TransactionHash from a Deploy hash.
     * @param hash The Deploy hash instance.
     * @returns A new TransactionHash instance with the deploy hash.
     */
    static fromDeployHash(hash: Hash): TransactionHash;
    /**
     * Creates a TransactionHash from a TransactionV1 hash.
     * @param hash The TransactionV1 hash instance.
     * @returns A new TransactionHash instance with the transactionV1 hash.
     */
    static fromTransactionHash(hash: Hash): TransactionHash;
    /**
     * Returns the hash (either deploy or transactionV1).
     * This method is useful when you want to get the hash regardless of type.
     */
    getHash(): Hash | undefined;
    /**
     * Converts the `TransactionHash` to a hexadecimal string representation.
     * @returns The hexadecimal string of the deploy or transactionV1 hash, or an empty string if neither is available.
     */
    toHex(): string;
    /**
     * Converts the `TransactionHash` to a byte array representation.
     * @returns The byte array of the deploy or transactionV1 hash, or an empty byte array if neither is available.
     */
    toBytes(): Uint8Array;
    /**
     * Converts the `TransactionHash` to a JSON string (hex format).
     * @returns The hexadecimal string representation of the hash.
     */
    toJSON(): string;
    /**
     * Checks if the current transaction hash is equal to another hash.
     * @param other The hash to compare with.
     * @returns True if the hashes are equal, otherwise false.
     */
    equals(other: Hash): boolean;
}
/**
 * Represents an approval for a transaction with a signer and signature.
 */
export declare class Approval {
    /**
     * The public key of the signer.
     */
    signer: PublicKey;
    /**
     * The signature of the transaction signed by the signer.
     */
    signature: HexBytes;
    /**
     * Constructs an `Approval` instance with a signer and signature.
     * @param signer The public key of the signer.
     * @param signature The signature of the transaction.
     */
    constructor(signer: PublicKey, signature: HexBytes);
    /**
     * Serializes an array of `Approval`s into a `Uint8Array` typed byte array.
     * This is used to store or transmit the approvals associated with a deploy.
     *
     * @param approvals An array of `Approval` objects that represent signatures from accounts that have approved the deploy.
     * @returns A `Uint8Array` typed byte array that can be deserialized back into an array of `Approval` objects.
     *
     * @example
     * const approvals = [new Approval(publicKey, signature)];
     * const serializedApprovals = Approval.toBytes(approvals);
     */
    static toBytes(approvals: Approval[]): Uint8Array;
}
/**
 * Represents a TransactionV1 object, including its hash, payload, and approvals.
 */
export declare class TransactionV1 {
    /**
     * The hash of the transaction.
     */
    hash: Hash;
    /**
     * The payload of the transaction.
     * A merge of header and body concepts from before.
     */
    payload: TransactionV1Payload;
    /**
     * The approvals for the transaction.
     */
    approvals: Approval[];
    constructor(hash: Hash, payload: TransactionV1Payload, approvals: Approval[]);
    /**
     * Validates the transaction by checking the transaction hash and the approval signatures.
     * @throws {TransactionError} Throws errors if validation fails.
     */
    validate(): boolean;
    /**
     * Signs the transaction using the provided private key.
     * @param keys The private key to sign the transaction.
     */
    sign(keys: PrivateKey): void;
    private static readonly HASH_FIELD_INDEX;
    private static readonly PAYLOAD_FIELD_INDEX;
    private static readonly APPROVALS_FIELD_INDEX;
    /**
     * Converts the TransactionV1 to a byte array for transmission or storage.
     * @returns A `Uint8Array` representing the TransactionV1 instance in byte format.
     */
    toBytes(): Uint8Array;
    /**
     * Sets an already generated signature to the transaction.
     * @param transaction The `TransactionV1` instance.
     * @param signature The Ed25519 or Secp256K1 signature.
     * @param publicKey The public key used to generate the signature.
     * @returns The updated `TransactionV1`.
     */
    static setSignature(transaction: TransactionV1, signature: Uint8Array, publicKey: PublicKey): TransactionV1;
    /**
     * Creates a new `TransactionV1` instance.
     * @param hash The hash of the transaction.
     * @param payload The payload of the transaction. A merge of header and body concepts from before.
     * @param approvals The approvals for the transaction.
     * @returns A new `TransactionV1` instance.
     */
    static newTransactionV1(hash: Hash, payload: TransactionV1Payload, approvals: Approval[]): TransactionV1;
    /**
     * Creates a new `TransactionV1` instance with a header and body.
     * @param payload The payload of the transaction. A merge of header and body concepts from before.
     * @returns A new `TransactionV1` instance.
     */
    static makeTransactionV1(payload: TransactionV1Payload): TransactionV1;
    /**
     * Converts a JSON representation of a `TransactionV1` to a `TransactionV1` object.
     * @param json A JSON representation of a `TransactionV1`.
     * @returns A `TransactionV1` object.
     * @throws {TransactionError} If parsing fails.
     */
    static fromJSON(json: any): TransactionV1;
    /**
     * Converts the `TransactionV1` object to a JSON representation.
     * @param transaction The `TransactionV1` object.
     * @returns A JSON version of the `TransactionV1`.
     */
    static toJSON: (transaction: TransactionV1) => import("typedjson").JsonTypes;
}
/**
 * A wrapper for a TransactionV1 or Deploy.
 */
export declare class Transaction {
    /**
     * The hash of the transaction.
     */
    hash: TransactionHash;
    /**
     * The name of the blockchain chain associated with this transaction.
     */
    chainName: string;
    /**
     * The timestamp when the transaction was created.
     */
    timestamp: Timestamp;
    /**
     * The time-to-live (TTL) duration of the transaction. It defines the expiration time for the transaction.
     */
    ttl: Duration;
    /**
     * The address of the initiator of the transaction.
     */
    initiatorAddr: InitiatorAddr;
    /**
     * The pricing mode used for the transaction, which may involve different cost mechanisms.
     */
    pricingMode: PricingMode;
    /**
     * The arguments for the transaction, which can be a map of values required by the entry point.
     */
    args: Args;
    /**
     * The target of the transaction, which specifies where the transaction is directed (e.g., a contract or account).
     */
    target: TransactionTarget;
    /**
     * The entry point of the transaction, specifying the method or action to be executed.
     */
    entryPoint: TransactionEntryPoint;
    /**
     * The scheduling information for when the transaction should be executed.
     */
    scheduling: TransactionScheduling;
    /**
     * The list of approvals for this transaction.
     */
    approvals: Approval[];
    /**
     * The original deployment associated with this transaction, if applicable.
     * This is optional and only populated if the transaction originated from a deploy.
     */
    private originDeployV1?;
    /**
     * The original TransactionV1 associated with this transaction, if applicable.
     * This is optional and only populated if the transaction is based on a TransactionV1.
     */
    private originTransactionV1?;
    /**
     * Creates a new `Transaction` instance with the specified values.
     * @param hash The hash of the transaction.
     * @param chainName The blockchain chain name associated with this transaction.
     * @param timestamp The timestamp of transaction creation.
     * @param ttl The time-to-live duration of the transaction.
     * @param initiatorAddr The address of the transaction initiator.
     * @param pricingMode The pricing mode for this transaction.
     * @param args The arguments for the transaction.
     * @param target The target of the transaction.
     * @param entryPoint The entry point of the transaction.
     * @param scheduling The scheduling information for the transaction.
     * @param approvals The list of approvals for this transaction.
     * @param originTransactionV1 The original TransactionV1, if applicable.
     * @param originDeployV1 The original deploy, if applicable.
     */
    constructor(hash: TransactionHash, chainName: string, timestamp: Timestamp, ttl: Duration, initiatorAddr: InitiatorAddr, pricingMode: PricingMode, args: Args, target: TransactionTarget, entryPoint: TransactionEntryPoint, scheduling: TransactionScheduling, approvals: Approval[], originTransactionV1?: TransactionV1, originDeployV1?: Deploy);
    /**
     * Gets the original deployment associated with this transaction, if available.
     * @returns The original deploy or `undefined` if not available.
     */
    getDeploy(): Deploy | undefined;
    /**
     * Gets the original TransactionV1 associated with this transaction, if available.
     * @returns The original TransactionV1 or `undefined` if not available.
     */
    getTransactionV1(): TransactionV1 | undefined;
    getTransactionWrapper(): TransactionWrapper;
    /**
     * Validates the transaction by checking the transaction hash and the approval signatures.
     * @throws {TransactionError} Throws errors if validation fails.
     */
    validate(): boolean;
    /**
     * Signs the transaction using the provided private key.
     * @param key The private key to sign the transaction.
     */
    sign(key: PrivateKey): void;
    /**
     * Sets an already generated signature to the transaction.
     * @param signature The Ed25519 or Secp256K1 signature.
     * @param publicKey The public key used to generate the signature.
     */
    setSignature(signature: Uint8Array, publicKey: PublicKey): void;
    /**
     * Converts the Transaction to a byte array for transmission or storage.
     * @returns A `Uint8Array` representing the Transaction instance in byte format.
     */
    toBytes(): Uint8Array;
    /**
     * Converts a `TransactionV1` to a `Transaction` object.
     * @param v1 The `TransactionV1` to convert.
     * @returns A new `Transaction` instance created from the given `TransactionV1`.
     */
    static fromTransactionV1(v1: TransactionV1): Transaction;
    /**
     * Converts a `TransactionV1` to a `Transaction` object.
     * @param deploy The `Deploy` to convert.
     * @returns A new `Transaction` instance created from the given `Deploy`.
     */
    static fromDeploy(deploy: Deploy): Transaction;
    static fromJSON(json: any): Transaction;
    toJSON(): import("typedjson").JsonTypes;
}
/**
 * Wrapper class for transactions, allowing for both `Deploy` and `TransactionV1` to be stored
 * in the same object. This can be useful when working with multiple versions of transactions.
 */
export declare class TransactionWrapper {
    /**
     * The deployment object associated with the transaction, if applicable.
     * This will contain the details of the deploy transaction.
     */
    deploy?: Deploy;
    /**
     * The version 1 transaction object, if applicable.
     * This will contain the details of a TransactionV1, which represents the first version of a transaction.
     */
    transactionV1?: TransactionV1;
    /**
     * Constructs a new `TransactionWrapper` instance with the provided `Deploy` and `TransactionV1` values.
     * @param deploy The `Deploy` object, if applicable.
     * @param transactionV1 The `TransactionV1` object, if applicable.
     */
    constructor(deploy?: Deploy, transactionV1?: TransactionV1);
    static toJSON(wrapper: TransactionWrapper): import("typedjson").JsonTypes;
}
