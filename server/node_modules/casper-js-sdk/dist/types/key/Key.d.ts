import { AccountHash } from './Account';
import { Hash } from './Hash';
import { TransferHash } from './Transfer';
import { Era } from './Era';
import { EntityAddr } from './EntityAddr';
import { BidAddr } from './BidAddr';
import { ByteCode } from './ByteCode';
import { MessageAddr } from './MessageAddr';
import { NamedKeyAddr } from './NewNamedKeyAddr';
import { BlockGlobalAddr } from './BlockGlobalAddr';
import { BalanceHoldAddr } from './BalanceHoldAddr';
import { EntryPointAddr } from './EntryPointAddr';
import { URef } from './URef';
import { IResultWithBytes } from '../clvalue';
/**
 * Enum that defines prefixes used to identify different types of blockchain entities and objects.
 */
export declare enum PrefixName {
    Account = "account-hash-",
    AddressableEntity = "addressable-entity-",
    Hash = "hash-",
    ContractPackageWasm = "contract-package-wasm",
    ContractPackage = "contract-package-",
    ContractWasm = "contract-wasm-",
    Contract = "contract-",
    URef = "uref-",
    Transfer = "transfer-",
    DeployInfo = "deploy-",
    EraId = "era-",
    Bid = "bid-",
    Balance = "balance-",
    Withdraw = "withdraw-",
    Dictionary = "dictionary-",
    SystemContractRegistry = "system-contract-registry-",
    EraSummary = "era-summary-",
    Unbond = "unbond-",
    ChainspecRegistry = "chainspec-registry-",
    EntityContract = "entity-contract-",
    ChecksumRegistry = "checksum-registry-",
    BidAddr = "bid-addr-",
    Package = "package-",
    Entity = "entity-",
    ByteCode = "byte-code-",
    Message = "message-",
    NamedKey = "named-key-",
    BlockGlobal = "block-",
    BalanceHold = "balance-hold-",
    EntryPoint = "entry-point-"
}
/**
 * Enum representing different types of blockchain key types used in the system.
 */
export declare enum KeyTypeID {
    Account = 0,
    Hash = 1,
    URef = 2,
    Transfer = 3,
    DeployInfo = 4,
    EraId = 5,
    Balance = 6,
    Bid = 7,
    Withdraw = 8,
    Dictionary = 9,
    SystemContractRegistry = 10,
    EraSummary = 11,
    Unbond = 12,
    ChainspecRegistry = 13,
    ChecksumRegistry = 14,
    BidAddr = 15,
    Package = 16,
    AddressableEntity = 17,
    ByteCode = 18,
    Message = 19,
    NamedKey = 20,
    BlockGlobal = 21,
    BalanceHold = 22,
    EntryPoint = 23
}
/**
 * Enum for human-readable key type names, used to represent various key entities in the blockchain.
 */
export declare enum KeyTypeName {
    Account = "Account",
    Hash = "Hash",
    URef = "URef",
    Transfer = "Transfer",
    Deploy = "Deploy",
    Era = "Era",
    Bid = "Bid",
    Balance = "Balance",
    Withdraw = "Withdraw",
    Dictionary = "Dictionary",
    SystemContractRegistry = "SystemContractRegistry",
    EraSummary = "EraSummary",
    Unbond = "Unbond",
    ChainspecRegistry = "ChainspecRegistry",
    ChecksumRegistry = "ChecksumRegistry"
}
/**
 * Mapping of key type names to their corresponding KeyTypeID values.
 */
export declare const typeIDbyNames: Map<KeyTypeName, KeyTypeID>;
/**
 * Mapping of blockchain key prefixes to their corresponding KeyKeyTypeID values.
 */
export declare const keyIDbyPrefix: Map<PrefixName, KeyTypeID>;
/**
 * Default byte length for keys.
 */
export declare const KEY_DEFAULT_BYTE_LENGTH = 32;
/**
 * Represents a Key that can identify different types of entities in the system.
 */
export declare class Key {
    type: KeyTypeID;
    account?: AccountHash;
    hash?: Hash;
    uRef?: URef;
    transfer?: TransferHash;
    deploy?: Hash;
    era?: Era;
    balance?: Hash;
    bid?: AccountHash;
    withdraw?: AccountHash;
    dictionary?: Hash;
    systemContactRegistry?: Hash;
    eraSummary?: Hash;
    unbond?: AccountHash;
    chainspecRegistry?: Hash;
    checksumRegistry?: Hash;
    bidAddr?: BidAddr;
    package?: Hash;
    addressableEntity?: EntityAddr;
    byteCode?: ByteCode;
    message?: MessageAddr;
    namedKey?: NamedKeyAddr;
    blockGlobal?: BlockGlobalAddr;
    balanceHold?: BalanceHoldAddr;
    entryPoint?: EntryPointAddr;
    /**
     * Converts the key to bytes.
     * @returns A Uint8Array representing the serialized key.
     */
    bytes(withKeyTypeID?: boolean): Uint8Array;
    /**
     * Concatenates the type and field bytes.
     * @param typeBytes - The bytes representing the type.
     * @param fieldBytes - The bytes representing the field.
     * @returns A Uint8Array with concatenated type and field bytes.
     */
    private static concatBytes;
    /**
     * Converts the instance to a JSON-compatible hexadecimal string.
     *
     * @returns {string} The hex-encoded string representation of the instance.
     */
    toJSON(): string;
    /**
     * Converts the key to a prefixed string representation.
     * @returns The prefixed string of the key.
     */
    toPrefixedString(): string;
    /**
     * Converts the key to a string representation.
     * @returns The string representation of the key.
     */
    toString(): string;
    /**
     * Creates a Key instance from a byte array.
     * @param bytes - The byte array containing serialized key data.
     * @returns A new Key instance.
     * @throws Error if deserialization fails.
     */
    static fromBytes(bytes: Uint8Array): IResultWithBytes<Key>;
    /**
     * Finds the prefix name by matching the source string with a map of prefixes.
     * @param source - The string to check for a matching prefix.
     * @param prefixes - The map of prefix names to KeyTypeID.
     * @returns The matching PrefixName or undefined if not found.
     */
    static findPrefixByMap(source: string, prefixes: Map<PrefixName, KeyTypeID>): PrefixName;
    /**
     * Creates a Key instance based on the type ID and source string.
     * @param source - The string containing the key data.
     * @param typeID - The TypeID of the key.
     * @returns A new Key instance.
     * @throws Error if the type is not found or invalid.
     */
    static createByType(source: string, typeID: KeyTypeID): Key;
    /**
     * Parses a Key instance from a string representation.
     * @param source - The string containing the key data.
     * @returns A new Key instance.
     * @throws Error if the format is invalid or unexpected.
     */
    static parseTypeByString(source: string): Key;
    /**
     * Creates a new Key instance from a source string.
     * @param source - The string containing the key data.
     * @returns A new Key instance.
     * @throws Error if the prefix is not found or the source is invalid.
     */
    static newKey(source: string): Key;
}
/**
 * Splits the array at a given index.
 * @param i - The index to split the array.
 * @param arr - The Uint8Array to split.
 * @returns A new Uint8Array from the start to index i.
 * @throws Error if the index is out of bounds.
 */
export declare const splitAt: (i: number, arr: Uint8Array) => Uint8Array[];
